{
  "$schema": "../../metadata/schema.json",
  "metadata": {
    "category": "advanced",
    "subcategory": "generics-mc",
    "fileVersion": 1,
    "lastUpdated": "2025-01-29T16:00:00Z",
    "questionCount": 10,
    "avgDifficulty": 5.8
  },
  "questions": [
    {
      "id": "gen-0001",
      "question": "What does each method call output in the generic constraint example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Value: 42\nLength: 5",
          "explanation": "Generic constraints allow calling specific methods. new() constraint enables parameterless constructor, IFormattable enables ToString formatting."
        },
        {
          "id": "b",
          "text": "Compilation error - constraints not satisfied",
          "explanation": "Both int and string satisfy their respective constraints."
        },
        {
          "id": "c",
          "text": "Value: 0\nLength: 0",
          "explanation": "The constraints are properly satisfied and methods work as expected."
        },
        {
          "id": "d",
          "text": "Runtime exception due to constraint violation",
          "explanation": "Constraint violations are compile-time errors, not runtime exceptions."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Generic constraints restrict type parameters to specific capabilities. The 'new()' constraint requires a parameterless constructor, while interface constraints allow calling interface methods.",
      "codeExample": {
        "language": "csharp",
        "code": "public static T CreateAndProcess<T>() where T : new(), IFormattable\n{\n    T instance = new T();\n    Console.WriteLine($\"Value: {instance.ToString(null, null)}\");\n    return instance;\n}\n\npublic static void ProcessString<T>(T value) where T : class\n{\n    Console.WriteLine($\"Length: {(value as string)?.Length ?? 0}\");\n}\n\n// Usage:\nCreateAndProcess<int>();  // int has parameterless constructor and implements IFormattable\nProcessString(\"Hello\");   // string is a reference type (class constraint)"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 5,
      "tags": [
        "generics",
        "constraints",
        "new-constraint",
        "interface-constraint",
        "class-constraint"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0002",
      "question": "What is the output of this C# generic covariance and contravariance example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Covariance works: True\nContravariance works: True",
          "explanation": "IEnumerable<T> is covariant (out T), Action<T> is contravariant (in T), enabling safe type conversions."
        },
        {
          "id": "b",
          "text": "Both conversions fail",
          "explanation": "Generic variance allows these safe conversions when properly declared."
        },
        {
          "id": "c",
          "text": "Only covariance works",
          "explanation": "Both covariance and contravariance work with the correct generic types."
        },
        {
          "id": "d",
          "text": "Compilation error - invalid cast",
          "explanation": "These are valid variance conversions supported by the type system."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Covariance (out) allows derived-to-base conversions for output positions. Contravariance (in) allows base-to-derived conversions for input positions. This enables safe generic type conversions.",
      "codeExample": {
        "language": "csharp",
        "code": "// Covariance example - IEnumerable<out T>\nIEnumerable<string> strings = new List<string> {\"hello\", \"world\"};\nIEnumerable<object> objects = strings;  // string -> object (covariant)\nConsole.WriteLine($\"Covariance works: {objects != null}\");\n\n// Contravariance example - Action<in T>\nAction<object> objectAction = obj => Console.WriteLine(\"Processing object\");\nAction<string> stringAction = objectAction;  // object -> string (contravariant)\nConsole.WriteLine($\"Contravariance works: {stringAction != null}\");\n\n// Note: \n// - Covariance: can return more derived types\n// - Contravariance: can accept more base types"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 7,
      "tags": [
        "generics",
        "covariance",
        "contravariance",
        "variance",
        "out-in-keywords"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0003",
      "question": "What will this C# generic method overload resolution code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Generic method: 42\nNon-generic method: Hello",
          "explanation": "C# compiler prefers non-generic methods over generic ones when both are applicable."
        },
        {
          "id": "b",
          "text": "Generic method: 42\nGeneric method: Hello",
          "explanation": "Non-generic methods have higher precedence in overload resolution."
        },
        {
          "id": "c",
          "text": "Compilation error - ambiguous call",
          "explanation": "Overload resolution rules clearly prefer non-generic methods."
        },
        {
          "id": "d",
          "text": "Both calls use generic method",
          "explanation": "The string call uses the non-generic overload."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "In C# overload resolution, non-generic methods are preferred over generic methods when both are applicable. This avoids ambiguity and provides predictable behavior.",
      "codeExample": {
        "language": "csharp",
        "code": "public static void Process<T>(T value)\n{\n    Console.WriteLine($\"Generic method: {value}\");\n}\n\npublic static void Process(string value)\n{\n    Console.WriteLine($\"Non-generic method: {value}\");\n}\n\npublic static void Main()\n{\n    Process(42);      // Calls generic method (no specific overload for int)\n    Process(\"Hello\"); // Calls non-generic method (specific string overload exists)\n}\n\n// Overload resolution preference:\n// 1. Exact type match (non-generic)\n// 2. Generic method\n// 3. Implicit conversions"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 6,
      "tags": [
        "generics",
        "overload-resolution",
        "method-precedence",
        "type-inference"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0004",
      "question": "What is the output of this C# generic delegate and Func<T> example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Custom delegate: 25\nFunc delegate: 36",
          "explanation": "Generic delegates provide type safety and reusability. Custom and built-in delegates work similarly."
        },
        {
          "id": "b",
          "text": "Type mismatch error",
          "explanation": "Generic delegates ensure type safety at compile time."
        },
        {
          "id": "c",
          "text": "Both return the same value",
          "explanation": "Different lambda expressions produce different results (5²=25, 6²=36)."
        },
        {
          "id": "d",
          "text": "Compilation error - delegate type mismatch",
          "explanation": "Both delegates have compatible signatures for their respective lambda expressions."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Generic delegates provide type-safe function pointers. Func<T, TResult> is a built-in generic delegate, while custom generic delegates offer more semantic meaning.",
      "codeExample": {
        "language": "csharp",
        "code": "// Custom generic delegate\npublic delegate TResult Calculator<T, TResult>(T input);\n\npublic static void Main()\n{\n    // Custom generic delegate\n    Calculator<int, int> customCalc = x => x * x;\n    int result1 = customCalc(5);\n    Console.WriteLine($\"Custom delegate: {result1}\");\n    \n    // Built-in Func delegate (equivalent functionality)\n    Func<int, int> funcCalc = x => x * x;\n    int result2 = funcCalc(6);\n    Console.WriteLine($\"Func delegate: {result2}\");\n}\n\n// Benefits of generic delegates:\n// - Type safety\n// - Reusability across different types\n// - IntelliSense support"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 5,
      "tags": [
        "generics",
        "delegates",
        "func-delegate",
        "lambda-expressions",
        "type-safety"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0005",
      "question": "What will this C# generic type parameter inheritance code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Base method called\nDerived method called",
          "explanation": "Generic type parameters can have inheritance constraints, allowing polymorphic behavior within generic contexts."
        },
        {
          "id": "b",
          "text": "Both call base method",
          "explanation": "The second call uses a derived type that overrides the virtual method."
        },
        {
          "id": "c",
          "text": "Compilation error - constraint violation",
          "explanation": "Both Animal and Dog satisfy the 'where T : Animal' constraint."
        },
        {
          "id": "d",
          "text": "Runtime type checking required",
          "explanation": "Generic constraints provide compile-time type safety."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Generic type parameter constraints can specify inheritance relationships, enabling polymorphic method calls within generic methods while maintaining type safety.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Animal\n{\n    public virtual void MakeSound() => Console.WriteLine(\"Base method called\");\n}\n\npublic class Dog : Animal\n{\n    public override void MakeSound() => Console.WriteLine(\"Derived method called\");\n}\n\npublic static void ProcessAnimal<T>(T animal) where T : Animal\n{\n    animal.MakeSound();  // Polymorphic call through constraint\n}\n\npublic static void Main()\n{\n    ProcessAnimal(new Animal());\n    ProcessAnimal(new Dog());\n}\n\n// The constraint 'where T : Animal' ensures:\n// 1. T has all Animal members\n// 2. Polymorphic behavior works\n// 3. Type safety at compile time"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 6,
      "tags": [
        "generics",
        "inheritance-constraints",
        "polymorphism",
        "virtual-methods",
        "type-parameters"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0006",
      "question": "What is the output of this C# generic type reflection and typeof example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Open generic: Repository`1[T]\nClosed generic: Repository`1[System.String]\nSame definition: True",
          "explanation": "Open generics have unbound type parameters, closed generics have specific types. GetGenericTypeDefinition returns the open form."
        },
        {
          "id": "b",
          "text": "Both show the same type information",
          "explanation": "Open and closed generic types have different representations."
        },
        {
          "id": "c",
          "text": "Cannot get type information for generics",
          "explanation": "Reflection works with both open and closed generic types."
        },
        {
          "id": "d",
          "text": "Type comparison always returns false",
          "explanation": "GetGenericTypeDefinition allows comparing the underlying generic structure."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Generic types have different representations in reflection. Open generics have unbound type parameters, while closed generics are bound to specific types. GetGenericTypeDefinition() returns the open generic form.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Repository<T>\n{\n    public T GetData() => default(T);\n}\n\npublic static void Main()\n{\n    // Open generic type (unbound)\n    Type openGeneric = typeof(Repository<>);\n    Console.WriteLine($\"Open generic: {openGeneric.Name}\");\n    \n    // Closed generic type (bound to string)\n    Type closedGeneric = typeof(Repository<string>);\n    Console.WriteLine($\"Closed generic: {closedGeneric.Name}\");\n    \n    // Compare generic type definitions\n    bool sameDefinition = openGeneric == closedGeneric.GetGenericTypeDefinition();\n    Console.WriteLine($\"Same definition: {sameDefinition}\");\n}\n\n// Uses for generic reflection:\n// - Generic factory patterns\n// - Dynamic type creation\n// - Framework development"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 6,
      "tags": [
        "generics",
        "reflection",
        "typeof",
        "open-generics",
        "closed-generics"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0007",
      "question": "What will this C# generic default(T) and constraints code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Value type default: 0\nReference type default: \nNullable default: ",
          "explanation": "default(T) returns type-specific defaults: 0 for int, null for string (prints empty), null for nullable types."
        },
        {
          "id": "b",
          "text": "All defaults are null",
          "explanation": "Value types have non-null defaults (0 for int)."
        },
        {
          "id": "c",
          "text": "Compilation error with default(T)",
          "explanation": "default(T) is valid for all types in generic contexts."
        },
        {
          "id": "d",
          "text": "Runtime exception for value types",
          "explanation": "default(T) safely returns appropriate defaults for all types."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The default(T) expression returns the default value for type T: default values for value types, null for reference types, and null for nullable types.",
      "codeExample": {
        "language": "csharp",
        "code": "public static T GetDefault<T>()\n{\n    return default(T);\n}\n\npublic static void Main()\n{\n    // Value type default\n    int intDefault = GetDefault<int>();\n    Console.WriteLine($\"Value type default: {intDefault}\");\n    \n    // Reference type default\n    string stringDefault = GetDefault<string>();\n    Console.WriteLine($\"Reference type default: {stringDefault ?? \"null\"}\");\n    \n    // Nullable type default\n    int? nullableDefault = GetDefault<int?>();\n    Console.WriteLine($\"Nullable default: {nullableDefault?.ToString() ?? \"null\"}\");\n}\n\n// default(T) is useful for:\n// - Initializing generic fields\n// - Providing fallback values\n// - Generic factory methods"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 5,
      "tags": [
        "generics",
        "default-operator",
        "value-types",
        "reference-types",
        "nullable-types"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0008",
      "question": "What is the output of this C# generic method type inference code?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Inferred type: System.Int32\nExplicit type: System.String",
          "explanation": "C# can infer generic type parameters from method arguments, but explicit type parameters override inference."
        },
        {
          "id": "b",
          "text": "Both use the same inferred type",
          "explanation": "Explicit type specification overrides type inference."
        },
        {
          "id": "c",
          "text": "Type inference fails",
          "explanation": "Type inference works when sufficient information is available from arguments."
        },
        {
          "id": "d",
          "text": "Compilation error - ambiguous types",
          "explanation": "Type inference and explicit types both work correctly here."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "C# compiler can infer generic type parameters from method arguments. When type parameters are explicitly specified, they override the inference mechanism.",
      "codeExample": {
        "language": "csharp",
        "code": "public static void PrintType<T>(T value)\n{\n    Console.WriteLine($\"Type: {typeof(T)}\");\n}\n\npublic static void Main()\n{\n    // Type inference from argument\n    PrintType(42);  // T inferred as int\n    Console.WriteLine(\"Inferred type: System.Int32\");\n    \n    // Explicit type parameter\n    PrintType<string>(\"Hello\");  // T explicitly specified as string\n    Console.WriteLine(\"Explicit type: System.String\");\n}\n\n// Type inference works when:\n// - Method arguments provide sufficient type information\n// - No ambiguity exists\n// - Type constraints are satisfied\n\n// Explicit types are needed when:\n// - Inference is ambiguous\n// - Return type differs from argument types\n// - No arguments provide type information"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 5,
      "tags": [
        "generics",
        "type-inference",
        "explicit-types",
        "method-calls",
        "compiler"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0009",
      "question": "What will this C# generic interface implementation code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "String comparison: Hello vs World\nInt comparison: 5 vs 3",
          "explanation": "Generic interfaces allow type-specific implementations while maintaining common behavior patterns."
        },
        {
          "id": "b",
          "text": "All comparisons use same implementation",
          "explanation": "Different generic implementations can have type-specific behavior."
        },
        {
          "id": "c",
          "text": "Compilation error - generic interface conflict",
          "explanation": "A class can implement generic interfaces with different type parameters."
        },
        {
          "id": "d",
          "text": "Runtime type checking required",
          "explanation": "Generic interfaces provide compile-time type safety."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Generic interfaces enable type-safe contracts that can be implemented multiple times with different type parameters, providing polymorphic behavior with type safety.",
      "codeExample": {
        "language": "csharp",
        "code": "public interface IComparer<T>\n{\n    void Compare(T first, T second);\n}\n\npublic class MultiComparer : IComparer<string>, IComparer<int>\n{\n    public void Compare(string first, string second)\n    {\n        Console.WriteLine($\"String comparison: {first} vs {second}\");\n    }\n    \n    public void Compare(int first, int second)\n    {\n        Console.WriteLine($\"Int comparison: {first} vs {second}\");\n    }\n}\n\npublic static void Main()\n{\n    var comparer = new MultiComparer();\n    \n    IComparer<string> stringComparer = comparer;\n    stringComparer.Compare(\"Hello\", \"World\");\n    \n    IComparer<int> intComparer = comparer;\n    intComparer.Compare(5, 3);\n}"
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 6,
      "tags": [
        "generics",
        "interfaces",
        "multiple-implementations",
        "polymorphism",
        "type-safety"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    },
    {
      "id": "gen-0010",
      "question": "What is the output of this C# generic nested type and static member code?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Static int counter: 1\nStatic string counter: 1\nStatic int counter: 2",
          "explanation": "Each closed generic type has its own set of static members, providing type-specific static state."
        },
        {
          "id": "b",
          "text": "All counters share the same value",
          "explanation": "Each generic instantiation has separate static members."
        },
        {
          "id": "c",
          "text": "Static members are not allowed in generics",
          "explanation": "Generic types can have static members, with separate instances per type parameter."
        },
        {
          "id": "d",
          "text": "Counter resets for each type",
          "explanation": "Static members persist per generic type instantiation."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "Each closed generic type (generic type with specific type parameters) has its own set of static members. Container<int> and Container<string> have separate static fields.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Container<T>\n{\n    private static int counter = 0;\n    \n    public static void Increment()\n    {\n        counter++;\n        Console.WriteLine($\"Static {typeof(T).Name} counter: {counter}\");\n    }\n}\n\npublic static void Main()\n{\n    Container<int>.Increment();     // Increments Container<int>.counter\n    Container<string>.Increment();  // Increments Container<string>.counter (separate)\n    Container<int>.Increment();     // Increments Container<int>.counter again\n}\n\n// Key insight: Each generic type instantiation\n// (Container<int>, Container<string>, etc.)\n// has its own copy of static members.\n// This enables type-specific static state."
      },
      "category": "advanced",
      "subcategory": "generics-mc",
      "difficulty": 6,
      "tags": [
        "generics",
        "static-members",
        "type-instantiation",
        "separate-state",
        "closed-generics"
      ],
      "createdAt": "2025-01-29T16:00:00Z",
      "updatedAt": "2025-01-29T16:00:00Z",
      "version": 1
    }
  ]
}