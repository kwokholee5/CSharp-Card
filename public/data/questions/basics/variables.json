{
  "$schema": "../../metadata/schema.json",
  "metadata": {
    "category": "basics",
    "subcategory": "variables",
    "fileVersion": 1,
    "lastUpdated": "2025-08-29T10:00:00Z",
    "questionCount": 10,
    "avgDifficulty": 2.5
  },
  "questions": [
    {
      "id": "var-0001",
      "question": "What is the difference between 'var' and explicitly typing a variable in C#?",
      "type": "flip-card",
      "answer": "'var' uses implicit typing where the compiler infers the type at compile time, while explicit typing declares the type directly. Both result in strongly-typed variables.",
      "explanation": "The 'var' keyword is compile-time syntactic sugar that doesn't affect runtime performance. The compiler determines the type based on the initializer expression. Once assigned, the type cannot change.",
      "codeExample": {
        "language": "csharp",
        "code": "var implicitString = \"Hello\";  // Compiler infers string\nstring explicitString = \"World\"; // Explicitly typed as string\n// Both are strongly typed as string"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 2,
      "tags": ["var", "implicit-typing", "type-inference", "compilation"],
      "references": [
        {
          "title": "Microsoft Docs: var keyword",
          "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/var"
        }
      ],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0002",
      "question": "What are the naming conventions for variables in C#?",
      "type": "flip-card",
      "answer": "Local variables and parameters use camelCase, while public properties and methods use PascalCase. Private fields can use _camelCase or camelCase.",
      "explanation": "Following naming conventions improves code readability and maintainability. These conventions are widely adopted in the C# community and recommended by Microsoft.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Person\n{\n    private string _firstName;  // Private field with underscore\n    public string LastName { get; set; }  // Public property in PascalCase\n    \n    public void SetName(string firstName)  // Parameter in camelCase\n    {\n        _firstName = firstName;\n        string fullName = firstName + \" \" + LastName;  // Local variable in camelCase\n    }\n}"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 1,
      "tags": ["naming-conventions", "camelCase", "PascalCase", "code-style"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0003",
      "question": "What is the difference between const and readonly in C#?",
      "type": "flip-card",
      "answer": "const is compile-time constant and must be initialized at declaration, while readonly can be initialized at runtime in the constructor.",
      "explanation": "const values are replaced at compile time and can only be primitive types or strings. readonly fields are evaluated at runtime and can be any type, including reference types.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Example\n{\n    public const int MaxValue = 100;  // Must be initialized here\n    public readonly DateTime CreatedDate;  // Can be initialized in constructor\n    \n    public Example()\n    {\n        CreatedDate = DateTime.Now;  // Runtime initialization\n        // MaxValue = 200;  // Error: Cannot assign to const\n    }\n}"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 3,
      "tags": ["const", "readonly", "immutability", "constants"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0004",
      "question": "What is variable scope in C#?",
      "type": "flip-card",
      "answer": "Variable scope determines where a variable can be accessed in the code. Variables are accessible within the block they are declared in and any nested blocks.",
      "explanation": "C# uses block scope defined by curly braces {}. Variables declared in a block are not accessible outside of it, preventing naming conflicts and improving code organization.",
      "codeExample": {
        "language": "csharp",
        "code": "public void DemoScope()\n{\n    int outerVar = 1;  // Accessible in entire method\n    \n    if (true)\n    {\n        int innerVar = 2;  // Only accessible within if block\n        Console.WriteLine(outerVar);  // Valid\n        Console.WriteLine(innerVar);  // Valid\n    }\n    \n    Console.WriteLine(outerVar);  // Valid\n    // Console.WriteLine(innerVar);  // Error: innerVar not in scope\n}"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 2,
      "tags": ["scope", "block-scope", "variable-access", "lifetime"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0005",
      "question": "Can you declare multiple variables of the same type in one line in C#?",
      "type": "flip-card",
      "answer": "Yes, you can declare multiple variables of the same type in one line by separating them with commas.",
      "explanation": "This syntax allows for more compact variable declarations when multiple variables of the same type are needed. However, this cannot be used with the 'var' keyword as the compiler needs explicit type information.",
      "codeExample": {
        "language": "csharp",
        "code": "int x = 5, y = 10, z;  // Three int variables\nstring firstName = \"John\", lastName = \"Doe\";  // Two string variables\n// var a = 1, b = 2;  // Error: Cannot use var for multiple declarations"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 1,
      "tags": ["declaration", "multiple-variables", "syntax"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0006",
      "question": "What is a nullable type in C#?",
      "type": "flip-card",
      "answer": "Nullable types allow value types to represent null in addition to their normal range of values, using the ? suffix or Nullable<T> generic.",
      "explanation": "Value types normally cannot be null. Nullable types are useful when dealing with databases or optional values where the absence of a value needs to be represented.",
      "codeExample": {
        "language": "csharp",
        "code": "int? nullableInt = null;  // Can be null or any int value\nDateTime? optionalDate = null;\n\nif (nullableInt.HasValue)\n{\n    int value = nullableInt.Value;  // Access the value\n}\n\nint defaultValue = nullableInt ?? 0;  // Null-coalescing operator"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 3,
      "tags": ["nullable", "value-types", "null", "optional"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0007",
      "question": "What is the default value of uninitialized variables in C#?",
      "type": "flip-card",
      "answer": "Class fields get default values (0 for numbers, false for bool, null for references), but local variables must be initialized before use.",
      "explanation": "The C# compiler ensures that local variables are definitely assigned before use, preventing undefined behavior. Class fields are automatically initialized to their default values.",
      "codeExample": {
        "language": "csharp",
        "code": "public class DefaultValues\n{\n    int number;        // Default: 0\n    bool flag;         // Default: false\n    string text;       // Default: null\n    DateTime date;     // Default: DateTime.MinValue\n    \n    public void Method()\n    {\n        int local;  // No default value\n        // Console.WriteLine(local);  // Error: Use of unassigned local variable\n        local = 5;  // Must assign before use\n        Console.WriteLine(local);  // Now valid\n    }\n}"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 2,
      "tags": ["default-values", "initialization", "fields", "local-variables"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0008",
      "question": "What is the difference between value types and reference types in variable assignment?",
      "type": "flip-card",
      "answer": "Value types copy the actual value when assigned, while reference types copy the reference (memory address) to the object.",
      "explanation": "This fundamental difference affects how modifications to variables behave. Changes to a value type variable don't affect the original, while changes to reference type objects are visible through all references.",
      "codeExample": {
        "language": "csharp",
        "code": "// Value type\nint a = 5;\nint b = a;  // Copies the value\nb = 10;     // a is still 5\n\n// Reference type\nint[] arr1 = { 1, 2, 3 };\nint[] arr2 = arr1;  // Copies the reference\narr2[0] = 99;       // arr1[0] is also 99 now"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 4,
      "tags": ["value-types", "reference-types", "assignment", "memory"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0009",
      "question": "What is variable shadowing in C#?",
      "type": "flip-card",
      "answer": "Variable shadowing occurs when a variable in an inner scope has the same name as a variable in an outer scope, hiding the outer variable.",
      "explanation": "C# prevents accidental shadowing of local variables within the same method but allows it between class fields and local variables. This can lead to confusion if not handled carefully.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Shadow\n{\n    private int value = 10;  // Class field\n    \n    public void Method(int value)  // Parameter shadows field\n    {\n        Console.WriteLine(value);       // Refers to parameter\n        Console.WriteLine(this.value);  // Refers to field\n        \n        // int value = 5;  // Error: Cannot declare local with same name\n    }\n}"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 3,
      "tags": ["shadowing", "scope", "naming", "this-keyword"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    },
    {
      "id": "var-0010",
      "question": "What is the 'dynamic' keyword in C#?",
      "type": "flip-card",
      "answer": "The 'dynamic' keyword bypasses compile-time type checking, deferring type resolution to runtime, enabling dynamic typing scenarios.",
      "explanation": "Unlike 'var' which is compile-time type inference, 'dynamic' actually changes how the code behaves, allowing operations that would normally require reflection or wouldn't be possible with static typing.",
      "codeExample": {
        "language": "csharp",
        "code": "dynamic dynamicVar = 10;\nConsole.WriteLine(dynamicVar.GetType());  // System.Int32\n\ndynamicVar = \"Hello\";\nConsole.WriteLine(dynamicVar.GetType());  // System.String\n\ndynamicVar = new { Name = \"John\", Age = 30 };\nConsole.WriteLine(dynamicVar.Name);  // No compile-time checking"
      },
      "category": "basics",
      "subcategory": "variables",
      "difficulty": 4,
      "tags": ["dynamic", "runtime-typing", "late-binding", "flexibility"],
      "createdAt": "2025-08-29T09:00:00Z",
      "updatedAt": "2025-08-29T09:00:00Z",
      "version": 1
    }
  ]
}