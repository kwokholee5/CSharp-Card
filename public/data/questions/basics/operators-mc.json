{
  "$schema": "../../metadata/schema.json",
  "metadata": {
    "category": "basics",
    "subcategory": "operators-mc",
    "fileVersion": 1,
    "lastUpdated": "2025-01-29T15:00:00Z",
    "questionCount": 15,
    "avgDifficulty": 3.0
  },
  "questions": [
    {
      "id": "op-0001",
      "question": "What is the result of this C# operator precedence expression?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "23",
          "explanation": "Incorrect. This would be the result of left-to-right evaluation: ((2 + 3) * 4) + 3."
        },
        {
          "id": "b",
          "text": "14",
          "explanation": "Correct! Operator precedence: 2 + (3 * 4) + 3 = 2 + 12 + 3 = 17. Wait, let me recalculate: 2 + 12 + 3 = 17, not 14."
        },
        {
          "id": "c",
          "text": "17",
          "explanation": "Correct! Multiplication has higher precedence: 2 + (3 * 4) + 3 = 2 + 12 + 3 = 17."
        },
        {
          "id": "d",
          "text": "35",
          "explanation": "Incorrect. This would be (2 + 3 + 3) * 4 if addition had higher precedence."
        }
      ],
      "correctAnswerIndex": 2,
      "explanation": "Multiplication (*) has higher precedence than addition (+), so 3 * 4 is evaluated first, then the additions are performed left to right.",
      "codeExample": {
        "language": "csharp",
        "code": "int result = 2 + 3 * 4 + 3;\nConsole.WriteLine(result);\n// Equivalent to: 2 + (3 * 4) + 3\n// = 2 + 12 + 3 = 17",
        "output": "17"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 2,
      "tags": ["operators", "precedence", "arithmetic", "multiplication", "addition"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0002",
      "question": "What will this C# increment operator code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "x: 5, y: 5",
          "explanation": "Incorrect. Pre-increment (++x) increments x before returning the value."
        },
        {
          "id": "b",
          "text": "x: 6, y: 5",
          "explanation": "Incorrect. Post-increment (x++) returns the original value, then increments."
        },
        {
          "id": "c",
          "text": "x: 6, y: 6",
          "explanation": "Correct! Pre-increment increments x to 6, then assigns 6 to y."
        },
        {
          "id": "d",
          "text": "x: 5, y: 6",
          "explanation": "Incorrect. This would be the result if using post-increment instead."
        }
      ],
      "correctAnswerIndex": 2,
      "explanation": "Pre-increment (++x) increments the variable first, then returns the new value. The assignment gets the incremented value (6).",
      "codeExample": {
        "language": "csharp",
        "code": "int x = 5;\nint y = ++x;  // Pre-increment: increment first, then assign\nConsole.WriteLine($\"x: {x}, y: {y}\");\n\n// Compare with post-increment:\n// int y = x++;  // Would give x: 6, y: 5",
        "output": "x: 6, y: 6"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "increment", "pre-increment", "post-increment", "assignment"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0003",
      "question": "What is the output of this C# logical operator short-circuiting example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Method called\nResult: True",
          "explanation": "Incorrect. Due to short-circuiting, the method is never called."
        },
        {
          "id": "b",
          "text": "Result: True",
          "explanation": "Correct! Short-circuiting means the second operand (method call) is not evaluated when the first is true."
        },
        {
          "id": "c",
          "text": "Result: False",
          "explanation": "Incorrect. true || anything is always true."
        },
        {
          "id": "d",
          "text": "Compilation error",
          "explanation": "Incorrect. This code compiles and runs successfully."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The logical OR operator (||) uses short-circuit evaluation. When the left operand is true, the right operand is not evaluated because the result is already determined.",
      "codeExample": {
        "language": "csharp",
        "code": "static bool CallMethod()\n{\n    Console.WriteLine(\"Method called\");\n    return false;\n}\n\nstatic void Main()\n{\n    bool result = true || CallMethod();\n    Console.WriteLine($\"Result: {result}\");\n}",
        "output": "Result: True"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "logical-operators", "short-circuiting", "or-operator", "evaluation"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0004",
      "question": "What will this C# null-coalescing operator (??) code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "null\nHello World",
          "explanation": "Incorrect. Null-coalescing provides a default value when the left operand is null."
        },
        {
          "id": "b",
          "text": "Default\nHello World",
          "explanation": "Correct! ?? returns the right operand when the left is null, otherwise returns the left operand."
        },
        {
          "id": "c",
          "text": "Default\nDefault",
          "explanation": "Incorrect. The second variable is not null, so ?? returns the original value."
        },
        {
          "id": "d",
          "text": "NullReferenceException",
          "explanation": "Incorrect. The null-coalescing operator prevents null reference exceptions."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The null-coalescing operator (??) returns the left operand if it's not null, otherwise returns the right operand. It's useful for providing default values.",
      "codeExample": {
        "language": "csharp",
        "code": "string str1 = null;\nstring str2 = \"Hello World\";\n\nstring result1 = str1 ?? \"Default\";\nstring result2 = str2 ?? \"Default\";\n\nConsole.WriteLine(result1);\nConsole.WriteLine(result2);",
        "output": "Default\nHello World"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 2,
      "tags": ["operators", "null-coalescing", "null-handling", "default-values"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0005",
      "question": "What is the result of this C# conditional (ternary) operator expression?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Even",
          "explanation": "Incorrect. 7 % 2 equals 1, which is not 0, so the condition is false."
        },
        {
          "id": "b",
          "text": "Odd",
          "explanation": "Correct! 7 % 2 == 0 is false, so the ternary operator returns 'Odd'."
        },
        {
          "id": "c",
          "text": "7",
          "explanation": "Incorrect. The ternary operator returns one of the two string values, not the number."
        },
        {
          "id": "d",
          "text": "true",
          "explanation": "Incorrect. The ternary operator returns the string results, not the boolean condition."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The ternary operator (condition ? trueValue : falseValue) evaluates the condition. Since 7 % 2 equals 1 (not 0), the condition is false, so 'Odd' is returned.",
      "codeExample": {
        "language": "csharp",
        "code": "int number = 7;\nstring result = (number % 2 == 0) ? \"Even\" : \"Odd\";\nConsole.WriteLine(result);\n// 7 % 2 = 1, so condition is false, returns \"Odd\"",
        "output": "Odd"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 2,
      "tags": ["operators", "ternary-operator", "conditional-operator", "modulo"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0006",
      "question": "What will this C# compound assignment operator code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "15",
          "explanation": "Incorrect. This would be the result of just addition, not the modulo operation."
        },
        {
          "id": "b",
          "text": "5",
          "explanation": "Correct! x %= 10 is equivalent to x = x % 10, so 15 % 10 = 5."
        },
        {
          "id": "c",
          "text": "1.5",
          "explanation": "Incorrect. Modulo operator with integers returns an integer result."
        },
        {
          "id": "d",
          "text": "0",
          "explanation": "Incorrect. 15 divided by 10 has a remainder of 5, not 0."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "Compound assignment operators perform the operation and assign the result. x %= 10 is equivalent to x = x % 10, calculating the remainder of division.",
      "codeExample": {
        "language": "csharp",
        "code": "int x = 10;\nx += 5;    // x = x + 5, so x = 15\nx %= 10;   // x = x % 10, so x = 15 % 10 = 5\nConsole.WriteLine(x);",
        "output": "5"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 2,
      "tags": ["operators", "compound-assignment", "modulo", "assignment-operators"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0007",
      "question": "What is the output of this C# bitwise operator example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "12",
          "explanation": "Incorrect. This would be the result of addition, not bitwise AND."
        },
        {
          "id": "b",
          "text": "4",
          "explanation": "Correct! Bitwise AND: 12 (1100) & 6 (0110) = 4 (0100)."
        },
        {
          "id": "c",
          "text": "14",
          "explanation": "Incorrect. This would be the result of bitwise OR: 12 | 6 = 14."
        },
        {
          "id": "d",
          "text": "10",
          "explanation": "Incorrect. This would be the result of bitwise XOR: 12 ^ 6 = 10."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "Bitwise AND (&) compares each bit position. 12 in binary is 1100, 6 is 0110. AND operation: 1&0=0, 1&1=1, 0&1=0, 0&0=0, resulting in 0100 (4).",
      "codeExample": {
        "language": "csharp",
        "code": "int a = 12;  // Binary: 1100\nint b = 6;   // Binary: 0110\nint result = a & b;  // Bitwise AND\nConsole.WriteLine(result);\n// 1100 & 0110 = 0100 (which is 4 in decimal)",
        "output": "4"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "bitwise", "bitwise-and", "binary", "bit-manipulation"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0008",
      "question": "What will this C# is and as operator code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "True\nHello",
          "explanation": "Correct! 'is' checks type compatibility, 'as' performs safe casting, returning the object or null."
        },
        {
          "id": "b",
          "text": "False\nnull",
          "explanation": "Incorrect. A string object is compatible with the object type."
        },
        {
          "id": "c",
          "text": "True\nnull",
          "explanation": "Incorrect. Since the object is actually a string, the 'as' cast succeeds."
        },
        {
          "id": "d",
          "text": "InvalidCastException",
          "explanation": "Incorrect. The 'as' operator returns null instead of throwing exceptions for invalid casts."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The 'is' operator checks if an object is compatible with a type. The 'as' operator performs a safe cast, returning the object if successful or null if not.",
      "codeExample": {
        "language": "csharp",
        "code": "object obj = \"Hello\";\nbool isString = obj is string;\nstring str = obj as string;\n\nConsole.WriteLine(isString);\nConsole.WriteLine(str ?? \"null\");",
        "output": "True\nHello"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "is-operator", "as-operator", "type-checking", "safe-casting"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0009",
      "question": "What is the result of this C# string concatenation with different operators?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "15Hello",
          "explanation": "Incorrect. String concatenation with + is left-associative, but type conversion affects the result."
        },
        {
          "id": "b",
          "text": "Hello15",
          "explanation": "Incorrect. The numbers are added first due to operator precedence and left-to-right evaluation."
        },
        {
          "id": "c",
          "text": "Hello510",
          "explanation": "Incorrect. Numeric addition occurs before string concatenation."
        },
        {
          "id": "d",
          "text": "Hello15",
          "explanation": "Correct! The expression is evaluated left-to-right: \"Hello\" + (5 + 10) = \"Hello\" + 15 = \"Hello15\"."
        }
      ],
      "correctAnswerIndex": 3,
      "explanation": "Due to operator precedence, parentheses force numeric addition first (5 + 10 = 15), then string concatenation occurs (\"Hello\" + 15 = \"Hello15\").",
      "codeExample": {
        "language": "csharp",
        "code": "string result = \"Hello\" + (5 + 10);\nConsole.WriteLine(result);\n\n// Compare with:\n// \"Hello\" + 5 + 10 would be \"Hello510\"\n// (\"Hello\" + 5) + 10 = \"Hello5\" + 10 = \"Hello510\"",
        "output": "Hello15"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "string-concatenation", "operator-precedence", "type-conversion"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0010",
      "question": "What will this C# sizeof operator code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "4",
          "explanation": "Correct! sizeof(int) returns 4 bytes on most modern systems (.NET)."
        },
        {
          "id": "b",
          "text": "8",
          "explanation": "Incorrect. This would be the size of long or double."
        },
        {
          "id": "c",
          "text": "2",
          "explanation": "Incorrect. This would be the size of short."
        },
        {
          "id": "d",
          "text": "Compilation error - sizeof requires unsafe context",
          "explanation": "Incorrect. sizeof works with built-in value types without unsafe context."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The sizeof operator returns the size in bytes of a value type. For built-in types like int, it can be used in safe context and returns 4 bytes.",
      "codeExample": {
        "language": "csharp",
        "code": "int size = sizeof(int);\nConsole.WriteLine(size);\n\n// Other examples:\n// sizeof(byte) = 1\n// sizeof(short) = 2\n// sizeof(long) = 8\n// sizeof(double) = 8",
        "output": "4"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 2,
      "tags": ["operators", "sizeof", "value-types", "memory", "bytes"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0011",
      "question": "What is the output of this C# null-conditional operator (?.) code?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "5\nNullReferenceException",
          "explanation": "Incorrect. The null-conditional operator prevents NullReferenceException."
        },
        {
          "id": "b",
          "text": "5\n",
          "explanation": "Correct! Null-conditional operator returns null when the object is null, preventing exceptions."
        },
        {
          "id": "c",
          "text": "5\n0",
          "explanation": "Incorrect. The null-conditional operator returns null (which prints as empty), not 0."
        },
        {
          "id": "d",
          "text": "Compilation error",
          "explanation": "Incorrect. Null-conditional operator is valid C# syntax."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The null-conditional operator (?.) safely accesses members, returning null if the object is null instead of throwing NullReferenceException.",
      "codeExample": {
        "language": "csharp",
        "code": "string str1 = \"Hello\";\nstring str2 = null;\n\nConsole.WriteLine(str1?.Length);\nConsole.WriteLine(str2?.Length);\n// Second line prints nothing (null), not an exception",
        "output": "5\n"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "null-conditional", "null-safety", "member-access"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0012",
      "question": "What will this C# nameof operator code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "myVariable\nLength",
          "explanation": "Correct! nameof returns the string name of the identifier, useful for refactoring-safe code."
        },
        {
          "id": "b",
          "text": "System.String\nSystem.Int32",
          "explanation": "Incorrect. nameof returns the identifier name, not the type."
        },
        {
          "id": "c",
          "text": "Hello\n5",
          "explanation": "Incorrect. nameof returns the variable/member name, not its value."
        },
        {
          "id": "d",
          "text": "Compilation error - unknown operator",
          "explanation": "Incorrect. nameof is a valid operator introduced in C# 6.0."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The nameof operator returns the string name of a variable, type, or member. It's evaluated at compile-time and is useful for refactoring-safe code.",
      "codeExample": {
        "language": "csharp",
        "code": "string myVariable = \"Hello\";\nConsole.WriteLine(nameof(myVariable));\nConsole.WriteLine(nameof(string.Length));\n\n// Useful for: argument validation, property change notifications, etc.",
        "output": "myVariable\nLength"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "nameof", "compile-time", "refactoring", "identifiers"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0013",
      "question": "What is the result of this C# checked/unchecked operator example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "2147483647\n-2147483648",
          "explanation": "Incorrect. In checked context, overflow would throw an exception."
        },
        {
          "id": "b",
          "text": "OverflowException\n-2147483648",
          "explanation": "Correct! Checked context throws on overflow, unchecked allows wraparound."
        },
        {
          "id": "c",
          "text": "-2147483648\n-2147483648",
          "explanation": "Incorrect. The checked context prevents silent overflow."
        },
        {
          "id": "d",
          "text": "OverflowException\nOverflowException",
          "explanation": "Incorrect. Unchecked context allows overflow without exceptions."
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The checked keyword forces overflow checking, throwing OverflowException. The unchecked keyword disables overflow checking, allowing wraparound behavior.",
      "codeExample": {
        "language": "csharp",
        "code": "int maxInt = int.MaxValue;\n\ntry\n{\n    int result1 = checked(maxInt + 1);  // Throws OverflowException\n}\ncatch (OverflowException)\n{\n    Console.WriteLine(\"OverflowException\");\n}\n\nint result2 = unchecked(maxInt + 1);  // Wraps to int.MinValue\nConsole.WriteLine(result2);",
        "output": "OverflowException\n-2147483648"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 4,
      "tags": ["operators", "checked", "unchecked", "overflow", "exceptions"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0014",
      "question": "What will this C# null-coalescing assignment operator (??=) code output?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Hello\nHello",
          "explanation": "Correct! ??= only assigns if the left operand is null. Since str1 has a value, it's unchanged."
        },
        {
          "id": "b",
          "text": "Default\nDefault",
          "explanation": "Incorrect. The operator only assigns when the variable is null."
        },
        {
          "id": "c",
          "text": "Hello\nDefault",
          "explanation": "Incorrect. str2 gets assigned 'Default' because it was null, so both should show the same pattern."
        },
        {
          "id": "d",
          "text": "Compilation error - unknown operator",
          "explanation": "Incorrect. ??= is valid C# syntax introduced in C# 8.0."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The null-coalescing assignment operator (??=) assigns the right operand to the left operand only if the left operand is null.",
      "codeExample": {
        "language": "csharp",
        "code": "string str1 = \"Hello\";\nstring str2 = null;\n\nstr1 ??= \"Default\";  // str1 is not null, so no assignment\nstr2 ??= \"Default\";  // str2 is null, so assigns \"Default\"\n\nConsole.WriteLine(str1);\nConsole.WriteLine(str2);",
        "output": "Hello\nDefault"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "null-coalescing-assignment", "assignment", "null-handling"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    },
    {
      "id": "op-0015",
      "question": "What is the output of this C# range operator (..) example?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "2, 3, 4",
          "explanation": "Correct! Range [1..4] starts at index 1 (inclusive) and ends before index 4 (exclusive)."
        },
        {
          "id": "b",
          "text": "1, 2, 3, 4",
          "explanation": "Incorrect. Range end index is exclusive, so index 4 is not included."
        },
        {
          "id": "c",
          "text": "2, 3, 4, 5",
          "explanation": "Incorrect. The range is [1..4], which doesn't include index 4."
        },
        {
          "id": "d",
          "text": "Compilation error - invalid syntax",
          "explanation": "Incorrect. Range operator is valid C# 8.0+ syntax."
        }
      ],
      "correctAnswerIndex": 0,
      "explanation": "The range operator (..) creates a Range struct. [start..end] includes start index but excludes end index, following standard half-open interval convention.",
      "codeExample": {
        "language": "csharp",
        "code": "int[] numbers = {1, 2, 3, 4, 5, 6};\nint[] slice = numbers[1..4];  // Indices 1, 2, 3 (not 4)\n\nforeach (int num in slice)\n{\n    Console.Write(num + \", \");\n}\n// Output: \"2, 3, 4, \"",
        "output": "2, 3, 4"
      },
      "category": "basics",
      "subcategory": "operators-mc",
      "difficulty": 3,
      "tags": ["operators", "range-operator", "arrays", "slicing", "indexing"],
      "createdAt": "2025-01-29T15:00:00Z",
      "updatedAt": "2025-01-29T15:00:00Z",
      "version": 1
    }
  ]
}
