{
  "$schema": "../../metadata/schema.json",
  "metadata": {
    "category": "basics",
    "subcategory": "data-types-mc",
    "fileVersion": 1,
    "lastUpdated": "2025-08-29T12:00:00Z",
    "questionCount": 8,
    "avgDifficulty": 2.5
  },
  "questions": [
    {
      "id": "dtmc-0001",
      "question": "Which of the following is the correct way to declare a nullable integer in C#?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "int nullable = null;",
          "explanation": "This will cause a compile error since int is a value type and cannot be null"
        },
        {
          "id": "b",
          "text": "int? nullable = null;",
          "explanation": "Correct! The ? suffix makes the value type nullable"
        },
        {
          "id": "c",
          "text": "Nullable nullable = null;",
          "explanation": "This is missing the generic type parameter Nullable<int>"
        },
        {
          "id": "d",
          "text": "null int nullable = null;",
          "explanation": "This is not valid C# syntax"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "Nullable value types use the ? suffix syntax, which is shorthand for Nullable<T>. Regular value types cannot be assigned null without this modifier.",
      "codeExample": {
        "language": "csharp",
        "code": "int? nullableInt = null;\nif (nullableInt.HasValue)\n{\n    Console.WriteLine(nullableInt.Value);\n}\nelse\n{\n    Console.WriteLine(\"Value is null\");\n}",
        "output": "Value is null"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 2,
      "tags": ["nullable", "value-types", "syntax", "null"],
      "references": [
        {
          "title": "Microsoft Docs: Nullable value types",
          "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/nullable-value-types"
        }
      ],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0002",
      "question": "What is the default value of a bool variable in C#?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "null",
          "explanation": "bool is a value type, so it cannot be null by default"
        },
        {
          "id": "b",
          "text": "false",
          "explanation": "Correct! The default value for bool is false"
        },
        {
          "id": "c",
          "text": "true",
          "explanation": "false is the default value, not true"
        },
        {
          "id": "d",
          "text": "0",
          "explanation": "While false can be represented as 0, the default value is the bool false, not the integer 0"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "All value types have default values. For bool, the default is false. This is important when declaring class fields that aren't explicitly initialized.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Example\n{\n    public bool defaultBool;  // Will be false\n    \n    public void ShowDefault()\n    {\n        Console.WriteLine($\"Default bool value: {defaultBool}\");\n    }\n}",
        "output": "Default bool value: False"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 1,
      "tags": ["bool", "default-values", "value-types"],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0003",
      "question": "Which data type should you use for storing monetary values in C# applications?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "float",
          "explanation": "float has precision issues and is not suitable for monetary calculations"
        },
        {
          "id": "b",
          "text": "double",
          "explanation": "double also has floating-point precision issues that can cause errors in financial calculations"
        },
        {
          "id": "c",
          "text": "decimal",
          "explanation": "Correct! decimal is designed for financial and monetary calculations with exact precision"
        },
        {
          "id": "d",
          "text": "int",
          "explanation": "int cannot represent fractional monetary values like cents"
        }
      ],
      "correctAnswerIndex": 2,
      "explanation": "The decimal type is specifically designed for financial calculations where exact precision is required. It avoids the rounding errors inherent in binary floating-point types like float and double.",
      "codeExample": {
        "language": "csharp",
        "code": "// Avoid floating-point errors\ndouble wrongPrice = 0.1 + 0.2;  // 0.30000000000000004\ndecimal correctPrice = 0.1m + 0.2m;  // 0.3\n\nConsole.WriteLine($\"Wrong: {wrongPrice}\");\nConsole.WriteLine($\"Correct: {correctPrice}\");",
        "output": "Wrong: 0.30000000000000004\nCorrect: 0.3"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 3,
      "tags": ["decimal", "monetary", "precision", "floating-point"],
      "references": [
        {
          "title": "Microsoft Docs: decimal type",
          "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/floating-point-numeric-types"
        }
      ],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0004",
      "question": "What is the range of values for the byte data type in C#?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "-128 to 127",
          "explanation": "This is the range for sbyte (signed byte), not byte"
        },
        {
          "id": "b",
          "text": "0 to 255",
          "explanation": "Correct! byte is an unsigned 8-bit integer with range 0 to 255"
        },
        {
          "id": "c",
          "text": "-255 to 255",
          "explanation": "This range is not correct for any C# data type"
        },
        {
          "id": "d",
          "text": "0 to 256",
          "explanation": "Close, but byte goes from 0 to 255 (256 total values)"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "The byte type in C# is an unsigned 8-bit integer that can store values from 0 to 255. If you need negative values, use sbyte instead.",
      "codeExample": {
        "language": "csharp",
        "code": "byte minByte = byte.MinValue;  // 0\nbyte maxByte = byte.MaxValue;  // 255\n\nConsole.WriteLine($\"byte range: {minByte} to {maxByte}\");\n\n// sbyte for comparison\nsbyte minSByte = sbyte.MinValue;  // -128\nsbyte maxSByte = sbyte.MaxValue;  // 127\nConsole.WriteLine($\"sbyte range: {minSByte} to {maxSByte}\");",
        "output": "byte range: 0 to 255\nsbyte range: -128 to 127"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 2,
      "tags": ["byte", "range", "unsigned", "8-bit"],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0005",
      "question": "Which statement about string immutability in C# is correct?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "Strings can be modified in place using indexers",
          "explanation": "String indexers are read-only; you cannot modify a string using str[index] = 'x'"
        },
        {
          "id": "b",
          "text": "String operations create new string objects",
          "explanation": "Correct! Strings are immutable, so operations like concatenation create new string instances"
        },
        {
          "id": "c",
          "text": "Strings are mutable to improve performance",
          "explanation": "Strings are immutable by design, which actually helps with performance in many scenarios through interning"
        },
        {
          "id": "d",
          "text": "String immutability only applies to string literals",
          "explanation": "All string objects in C# are immutable, not just literals"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "Strings in C# are immutable reference types. Any operation that appears to modify a string actually creates a new string object. This is why StringBuilder is recommended for multiple string concatenations.",
      "codeExample": {
        "language": "csharp",
        "code": "string original = \"Hello\";\nstring modified = original + \" World\";  // Creates new string\n\nConsole.WriteLine($\"Original: {original}\");    // Still \"Hello\"\nConsole.WriteLine($\"Modified: {modified}\");    // \"Hello World\"\nConsole.WriteLine($\"Same reference: {object.ReferenceEquals(original, modified)}\");",
        "output": "Original: Hello\nModified: Hello World\nSame reference: False"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 3,
      "tags": ["string", "immutability", "reference-types", "performance"],
      "references": [
        {
          "title": "Microsoft Docs: Strings",
          "url": "https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/strings/"
        }
      ],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0006",
      "question": "What happens when you try to assign a long value to an int variable without explicit casting?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "The value is automatically truncated to fit",
          "explanation": "C# does not perform implicit narrowing conversions that could lose data"
        },
        {
          "id": "b",
          "text": "A compile-time error occurs",
          "explanation": "Correct! C# prevents implicit narrowing conversions to avoid data loss"
        },
        {
          "id": "c",
          "text": "The value is automatically converted",
          "explanation": "This would only happen for widening conversions (int to long), not narrowing ones"
        },
        {
          "id": "d",
          "text": "A runtime exception is thrown",
          "explanation": "The compiler catches this error at compile time, not runtime"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "C# prevents implicit narrowing conversions to avoid accidental data loss. You must use explicit casting when converting from a larger to smaller numeric type.",
      "codeExample": {
        "language": "csharp",
        "code": "long longValue = 1000000000L;\n\n// This causes compile error:\n// int intValue = longValue;\n\n// Explicit cast required:\nint intValue = (int)longValue;  // OK, but potential data loss\n\n// Safe conversion with checking:\nint safeValue = longValue > int.MaxValue ? int.MaxValue : (int)longValue;",
        "output": "Demonstrates explicit casting requirement for narrowing conversions"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 2,
      "tags": ["casting", "implicit-conversion", "data-loss", "compile-error"],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0007",
      "question": "Which keyword is used to create a constant that is evaluated at compile time?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "readonly",
          "explanation": "readonly fields are evaluated at runtime, not compile time"
        },
        {
          "id": "b",
          "text": "static",
          "explanation": "static indicates class-level membership but doesn't make something constant"
        },
        {
          "id": "c",
          "text": "const",
          "explanation": "Correct! const creates compile-time constants"
        },
        {
          "id": "d",
          "text": "final",
          "explanation": "final is a Java keyword, not used in C#"
        }
      ],
      "correctAnswerIndex": 2,
      "explanation": "The const keyword creates compile-time constants that are embedded directly into the calling code. They must be initialized with a constant expression and can only be primitive types, strings, or null.",
      "codeExample": {
        "language": "csharp",
        "code": "public class Constants\n{\n    public const int MaxItems = 100;        // Compile-time constant\n    public const string AppName = \"MyApp\";  // String constant\n    public readonly DateTime StartTime;      // Runtime constant\n    \n    public Constants()\n    {\n        StartTime = DateTime.Now;  // Set at runtime\n    }\n}",
        "output": "Shows difference between const and readonly"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 2,
      "tags": ["const", "constants", "compile-time", "readonly"],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    },
    {
      "id": "dtmc-0008",
      "question": "What is the difference between char and string in C#?",
      "type": "multiple-choice",
      "options": [
        {
          "id": "a",
          "text": "char is mutable, string is immutable",
          "explanation": "Both char and string are immutable, but char is a value type"
        },
        {
          "id": "b",
          "text": "char represents a single Unicode character, string represents a sequence of characters",
          "explanation": "Correct! char is a single 16-bit Unicode character, string is a sequence of chars"
        },
        {
          "id": "c",
          "text": "char uses single quotes, string uses double quotes, but they're otherwise the same",
          "explanation": "While the quote syntax differs, they're fundamentally different types with different capabilities"
        },
        {
          "id": "d",
          "text": "There is no difference; they're interchangeable",
          "explanation": "char and string are completely different types with different uses"
        }
      ],
      "correctAnswerIndex": 1,
      "explanation": "char is a value type representing a single 16-bit Unicode character, while string is a reference type representing a sequence of char values. They serve different purposes and have different behaviors.",
      "codeExample": {
        "language": "csharp",
        "code": "char singleChar = 'A';           // Single character\nstring multiChar = \"Hello\";      // Sequence of characters\n\nConsole.WriteLine($\"Char size: {sizeof(char)} bytes\");\nConsole.WriteLine($\"String length: {multiChar.Length} characters\");\nConsole.WriteLine($\"First char of string: {multiChar[0]}\");\nConsole.WriteLine($\"Char to string: {singleChar.ToString()}\");",
        "output": "Char size: 2 bytes\nString length: 5 characters\nFirst char of string: H\nChar to string: A"
      },
      "category": "basics",
      "subcategory": "data-types-mc",
      "difficulty": 2,
      "tags": ["char", "string", "unicode", "value-type", "reference-type"],
      "references": [
        {
          "title": "Microsoft Docs: char type",
          "url": "https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/builtin-types/char"
        }
      ],
      "createdAt": "2025-08-29T12:00:00Z",
      "updatedAt": "2025-08-29T12:00:00Z",
      "version": 1
    }
  ]
}